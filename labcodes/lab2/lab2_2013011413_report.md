# Lab 2 Report
计35 高思达 2013011413

gsd13@mails.tsinghua.edu.cn

## 练习〇 填写已有实验
使用meld工具可以很方便地进行代码的合并，只需要输入命令：`meld /lab1 /lab2`就能出现图形化的目录对比页面。点开文件后，两个文件中的不一样的地方可以很简单地通过点击来进行同步。但是，由于两个lab之间不同的文件比较多，所以还是需要查阅之前的报告来需找上次更改过的文件。lab1中更改过的是`kern/debug/kdebug.c`和`kern/trap/trap.c`。

由于lab1的challenge没有自己完成，而只是阅读了答案的代码，并直接拷贝到了lab1中添加注释，所以在lab2中并没有加入这部分代码。

为了方便起见，每份报告的一开始都会列出本次实验修改的文件：

* `kern/mm/default_pmm.c`


## 练习一 实现 first-fit 连续物理内存分配算法
#####0、本练习中涉及到的原理课中的知识点
涉及了物理内存的分配算法（First Fit）。在阅读代码中，还需要对分段和分页机制有所了解。

在原理课之外，代码实现中还涉及了对可用物理内存的初始化管理，以及对于页/空闲快标志位的设置细节，这些都是原理课中没有涉及的。

#####1、初步理解代码
* 我们在初始化内存管理的时候，使用的是`default_pmm_manager`，我们实现也是实现它的接口；
* `free_area_t`是真的存放在空闲内存块的头部的，所以其中只有前后指针和大小，而没有指向内存块的指针（或者类似的成员）；
* `default_init`初始化，不涉及探测可用空间的任务，只是准备好一个空的数据结构。

#####2、init\_memmap的理解和实现
* 探测物理内存通过系统调用，所谓`E820`是调用参数；BIOS中通过系统调用填写了这一部分，即存在了`e820map`；
* 调用`init_memmap`的函数是`page_init`，需要注意的是，这时ucore运行在保护模式下，有段机制，所以寻址时的逻辑地址都带有`0xC0000000`的偏移，比如该函数中的`end`。在`page_init`中，函数首先遍历`e820map`中的空闲地址块，统计页数，分配`Page`数组的空间。然后再对每一块调用`init_memmap`；
* 维护标志位时，只关注每一块的第一页即可，因为只有第一页是维护在空闲链表中的。

#####3、alloc\_pages的实现
* 需要修改的部分主要是页标志的设置，以及对于剩下的空闲空间插入链表的位置（插入后要保证地址递增）。

#####4、free\_pages的实现
* 原本的实现，应该不是针对first_fit的，该实现中没有利用链表的有序性（地址升序），也没有正确地插入新的空闲快；
* 重构这个函数，首先遍历链表找到插入位置，并插入刚刚释放的块；
* 然后，利用链表的有序性，我们只需要向前看一块，向后看一块，进行合并即可；合并时就不用遍历整个链表了。
* 这个函数一开始使用了一个循环更改区间内所有页的标志位，实际上只更改base的标志就够了；全部更改反而无法通过测试。

#####5、算法的改进空间
算法中，明显效率低下的地方是在回收空间时，把新的空闲快插入链表时，需要遍历链表。这个定位过程最坏情况下要遍历所有的空闲块（整个内存空间）。可以使用一些高级的数据结构，比如平衡树等，来加快这一查找定位过程。

#####6、和答案实现的区别
答案中，把每一个空闲页都加入了链表管理。然而事实上，只需要管理较大的内存块，链表中只需要放每块的第一页即可。如果每一页都在链表中，回收内存时的定位过程将会花费更多时间。在我的实现中，空闲链表中只管理每块开头的一页。和同学的讨论中发现，在建立了页机制后，反正也是一页一页地分配，所以即便像我这么实现，到最后还是一页一页地管理，效果是一样的。

同时，我只保留了必要的状态位修改和设置过程，并不像答案中做的那么冗余。标志位的设置方法，因为一开始没有看到代码中的注释，比较费解，但其实是很清晰的。Property位仅对于空闲块的头部页为1，否则为0；而Reserved仅仅对kernel保留的页是1，也就是所有可分配的页都是0。对应的注释在`kern/mm/memlayout.h`的108和109行。


## 练习二 实现寻找虚拟地址对应的页表项
#####0、本练习中涉及到的原理课中的知识点
本练习中主要涉及的是二级页表的组织形式和查找流程，其中尤其需要了解虚拟地址的构成。其中涉及了部分原理课中没有介绍的细节：新页表的建立和初始化方法，页目录项的填写和标志位设置方法。

#####1、阅读代码和实现中的要点
* `get_pte`是一路从线性地址查到了页表项，即查了两级页表；
* 参照注释，和其中提示的宏可以很容易地完成。在查到对应的页目录项后，分两种情况进行操作。如果页表存在，则直接查页表。否则，建立一张新的页表，清空它（初始化），填写页目录表中的表项，并返回对应位置的指针。
* 编程中，注意使用数组语法查页表时，必须先把页表的物理地址转换成虚拟地址。因为ucore是跑在保护模式下的，得使用虚拟地址才能找到数据。
* 值得注意的是，返回的页表项是指针形式。其指向的内容，即页表项本身，可能是全零的。调用者如果需要，则会去填写页表项中的内容。比如`boot_map_segment`函数在建立页机制时，在调用`get_pte`函数之后，就填写了它：

```
    pte_t *ptep = get_pte(pgdir, la, 1);
    assert(ptep != NULL);
    *ptep = pa | PTE_P | perm;
```

#####2、请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。

高20位是页表基址或者物理页帧的基址。低12位是标志位，其含义在`kern/mm/mmu.h`中定义：

```
/* page table/directory entry flags */
#define PTE_P           0x001                   // Present
#define PTE_W           0x002                   // Writeable
#define PTE_U           0x004                   // User
#define PTE_PWT         0x008                   // Write-Through
#define PTE_PCD         0x010                   // Cache-Disable
#define PTE_A           0x020                   // Accessed
#define PTE_D           0x040                   // Dirty
#define PTE_PS          0x080                   // Page Size
#define PTE_MBZ         0x180                   // Bits must be zero
#define PTE_AVAIL       0xE00                   // Available for software use
                                                // The PTE_AVAIL bits aren't used by the kernel or interpreted by the
                                                // hardware, so user processes are allowed to set them arbitrarily.
```

后面的值对应的是位数。转写下来是：

```
	第0位	PTE_P		存在位。为1时表示页存在在物理内存中。
	第1位	PTE_W		可写位。为1时表示可写，为0时只读。
	第2位	PTE_U		用户状态位。为1时，表明非ring0权限，即用户应用程序也可以访问。
	第3位	PTE_PWT	标识是否写直达（Cache写策略）。
	第4位	PTE_PCD	标识是否使能Cache。
	第5位	PTE_A		访问位。访问过置1。用于页面替换算法中。
	第6位	PTE_D		脏位。该页修改过为1。用户写回策略和一些页面替换算法。
	第7位	PTE_PS		页大小位。若该位为1使用4MB页大小。
	第8位	PTE_MBZ	必须置为0。
	第9位	PTE_AVAIL	加上第10位和第11位，留给软件自行使用。
```

注意，以上页表项标志位的语义对于页目录项未必都适用。比如，第6位脏位，页目录项是用不到的（页表一旦建立不会换出到外存，且老得修改，脏位当然没用）。

对于ucore而言，主要是辅助实现地址映射机制。具体而言，可以实现内存的保护机制（比如第1位的读写保护和第2位的权限保护）；同时，访问位和脏位在页面置换算法中都要用到。而和Cache有关的位，则是硬件看的，即是ucore控制硬件的一种方法。


#####3、如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

出现缺页异常时，硬件首先会记录下产生异常的线性地址（到CR2寄存器中）；同时保存错误码到中断栈。
然后启动标准的中断处理过程，即把相关的寄存器压栈保存现场，并跳到中断处理程序。ucore中产生的异常不涉及状态转变（本来就在核心态），也就不需要转换堆栈，因此不必在栈上保存原来的堆栈信息。

#####4、和答案实现的区别
通过阅读答案，发现我的实现和答案实现中做的事情完全一致，说明实现正确。但是，答案实现得更加集约，比如没有像我一样分页存在和不存在两种情况来写，而是在页表不存在时，先建立页表，再一并查找。此外，答案中也把比较复杂的查找过程浓缩成了一个表达式。

为了练习和易读性，用我的实现方法比较清晰。但是，kernel实现比较注重效率，所以答案的集约实现是很值得学习的。


## 练习三 释放某虚地址所在的页并取消对应二级页表项的映射
#####0、本练习中涉及到的原理课中的知识点
本练习依然涉及二级页表的映射机制。在实验中，涉及的是原理课中完全没有讲过的释放虚页的过程。其中，涉及到的引用计数的概念，以及对TLB的同步修改，也是原理课没有涉及的。


#####1、阅读代码和实现中的要点
* 在被释放的页存在时，我们一方面需要查看它更新后的引用情况，并在需要时释放内存；一方面也需要修改页表和TLB，接触这块内存对应的物理映射机制。
* 这个函数完全按照注释的提示写就可以了。需要额外注意的是引用计数机制的操作（并非直接释放页，由于页可能共享，只有在没人引用该页时才释放）。此外，注意TLB表的内容也是软件可以设置的，所以我们不能忘记清空TLB。
* 注意理解引用机制：释放的是逻辑地址（线性地址），它是一定没用了的，即映射关系一定要解除；但是，物理内存的内容可能还有引用的，所以未必需要释放物理空间。

#####2、数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

`Page`结构的每一项都对应内存中的一个页。页目录表和页表各自所在的页都能在`Page`结构的全局数组中找到。

但是，经过二级页表机制，对应到的页，和`Page`数组中的项的下标，应当并没有对应关系。因为一个虚拟地址对应到的二级页表中的表项的位置是确定的，但是它实际对应的物理地址则是找空闲区域分配的，即物理页的位置是不确定的，而`Page`数组的序号恰好能和物理地址的页序号（地址升序）相对应。因此，`Page`数组中的页项，并不对应二级页表中的页表项。

此外，`Page`结构体中的属性，即`flags, property, ref, page_link`，都是应对连续物理内存分配管理机制的，和页机制无关。二级页表的表项中，也没有对应这些属性的内容。因此可以说，除了页表本身各对应某一个`Page`结构以外，两者在序号和储存的内容上并没有什么对应关系。

#####3、如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？

直观来想，至少应该先把`KERNBASE`由`0xC0000000`改成`0x00000000`。
但是远没有这么简单，参照实验指导书中的[相关内容](https://objectkuan.gitbooks.io/ucore-docs/content/lab2/lab2_3_3_5_4_maping_relations.html)，我们还需要更改启动时的很多内容。比如`tools/kernel.ld`文件中的载入地址。根据文档中的提示，在`kern_entry`，以及启动时的各次段机制切换中，都需要做相应修改。

过程预计比较复杂，牵扯的代码比较多，且和本次实验主干较远，因此并没有动手实现。


#####4、和答案实现的区别
对比答案的实现发现基本一致。由于注释给得十分详细，也确实没有什么“自由发挥”的空间。不过答案的实现中有两点值得学习的地方：

* `page_ref_dec`能返回改动后的引用数，不需要再重复查；
* 页表项的清除大可不必“小心翼翼”地只改动存在位。不存在了整个页表项全部失效，直接全部清0即可。 
