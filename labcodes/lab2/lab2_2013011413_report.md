# Lab 2 Report
计35 高思达 2013011413

gsd13@mails.tsinghua.edu.cn

## 练习〇 填写已有实验
使用meld工具可以很方便地进行代码的合并，只需要输入命令：`meld /lab1 /lab2`就能出现图形化的目录对比页面。点开文件后，两个文件中的不一样的地方可以很简单地通过点击来进行同步。但是，由于两个lab之间不同的文件比较多，所以还是需要查阅之前的报告来需找上次更改过的文件。lab1中更改过的是`kern/debug/kdebug.c`和`kern/trap/trap.c`。

由于lab1的challenge没有自己完成，而只是阅读了答案的代码，并直接拷贝到了lab1中添加注释，所以在lab2中并没有加入这部分代码。

为了方便起见，每份报告的一开始都会列出本次实验修改的文件：

* `kern/mm/default_pmm.c`


## 练习一 实现 first-fit 连续物理内存分配算法
#####0、本练习中涉及到的原理课中的知识点
涉及了物理内存的分配算法（First Fit）。在阅读代码中，还需要对分段和分页机制有所了解。

在原理课之外，代码实现中还涉及了对可用物理内存的初始化管理，以及对于页/空闲快标志位的设置细节，这些都是原理课中没有涉及的。

#####1、初步理解代码
* 我们在初始化内存管理的时候，使用的是`default_pmm_manager`，我们实现也是实现它的接口；
* `free_area_t`是真的存放在空闲内存块的头部的，所以其中只有前后指针和大小，而没有指向内存块的指针（或者类似的成员）；
* `default_init`初始化，不涉及探测可用空间的任务，只是准备好一个空的数据结构。

#####2、init\_memmap的理解和实现
* 探测物理内存通过系统调用，所谓`E820`是调用参数；BIOS中通过系统调用填写了这一部分，即存在了`e820map`；
* 调用`init_memmap`的函数是`page_init`，需要注意的是，这时ucore运行在保护模式下，有段机制，所以寻址时的逻辑地址都带有`0xC0000000`的偏移，比如该函数中的`end`。在`page_init`中，函数首先遍历`e820map`中的空闲地址块，统计页数，分配`Page`数组的空间。然后再对每一块调用`init_memmap`；
* 维护标志位时，只关注每一块的第一页即可，因为只有第一页是维护在空闲链表中的。

#####3、alloc\_pages的实现
* 需要修改的部分主要是页标志的设置，以及对于剩下的空闲空间插入链表的位置（插入后要保证地址递增）。

#####4、free\_pages的实现
* 原本的实现，应该不是针对first_fit的，该实现中没有利用链表的有序性（地址升序），也没有正确地插入新的空闲快；
* 重构这个函数，首先遍历链表找到插入位置，并插入刚刚释放的块；
* 然后，利用链表的有序性，我们只需要向前看一块，向后看一块，进行合并即可；合并时就不用遍历整个链表了。
* 这个函数一开始使用了一个循环更改区间内所有页的标志位，实际上只更改base的标志就够了；全部更改反而无法通过测试。

#####5、算法的改进空间
算法中，明显效率低下的地方是在回收空间时，把新的空闲快插入链表时，需要遍历链表。这个定位过程最坏情况下要遍历所有的空闲块（整个内存空间）。可以使用一些高级的数据结构，比如平衡树等，来加快这一查找定位过程。

#####6、和答案实现的区别
答案中，把每一个空闲页都加入了链表管理。然而事实上，只需要管理较大的内存块，链表中只需要放每块的第一页即可。如果每一页都在链表中，回收内存时的定位过程将会花费更多时间。在我的实现中，空闲链表中只管理每块开头的一页。和同学的讨论中发现，在建立了页机制后，反正也是一页一页地分配，所以即便像我这么实现，到最后还是一页一页地管理，效果是一样的。

同时，我只保留了必要的状态位修改和设置过程，并不像答案中做的那么冗余。标志位的设置方法，因为一开始没有看到代码中的注释，比较费解，但其实是很清晰的。Property位仅对于空闲块的头部页为1，否则为0；而Reserved仅仅对kernel保留的页是1，也就是所有可分配的页都是0。对应的注释在`kern/mm/memlayout.h`的108和109行。


## 练习二 实现寻找虚拟地址对应的页表项
#####0、本练习中涉及到的原理课中的知识点
本练习中主要涉及的是二级页表的组织形式和查找流程，其中尤其需要了解虚拟地址的构成。其中涉及了部分原理课中没有介绍的细节：新页表的建立和初始化方法，页目录项的填写和标志位设置方法。

#####1、阅读代码和实现中的要点
* `get_pte`是一路从线性地址查到了页表项，即查了两级页表；
* 参照注释，和其中提示的宏可以很容易地完成。在查到对应的页目录项后，分两种情况进行操作。如果页表存在，则直接查页表。否则，建立一张新的页表，清空它（初始化），填写页目录表中的表项，并返回对应位置的指针。
* 编程中，注意使用数组语法查页表时，必须先把页表的物理地址转换成虚拟地址。因为ucore是跑在保护模式下的，得使用虚拟地址才能找到数据。
* 值得注意的是，返回的页表项是指针形式。其指向的内容，即页表项本身，可能是全零的。调用者如果需要，则会去填写页表项中的内容。比如`boot_map_segment`函数在建立页机制时，在调用`get_pte`函数之后，就填写了它：

```
    pte_t *ptep = get_pte(pgdir, la, 1);
    assert(ptep != NULL);
    *ptep = pa | PTE_P | perm;
```

#####2、请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。


#####3、如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

#####4、和答案实现的区别
通过阅读答案，发现我的实现和答案实现中做的事情完全一致，说明实现正确。但是，答案实现得更加集约，比如没有像我一样分页存在和不存在两种情况来写，而是在页表不存在时，先建立页表，再一并查找。此外，答案中也把比较复杂的查找过程浓缩成了一个表达式。

为了练习和易读性，用我的实现方法比较清晰。但是，kernel实现比较注重效率，所以答案的集约实现是很值得学习的。


## 练习三 释放某虚地址所在的页并取消对应二级页表项的映射
#####0、本练习中涉及到的原理课中的知识点


#####1、阅读代码和实现中的要点
* 在被释放的页存在时，我们一方面需要查看它更新后的引用情况，并在需要时释放内存；一方面也需要修改页表和TLB，接触这块内存对应的物理映射机制。
* 这个函数完全按照注释的提示写就可以了。需要额外注意的是引用计数机制的操作（并非直接释放页，由于页可能共享，只有在没人引用该页时才释放）。此外，注意TLB表的内容也是软件可以设置的，所以我们不能忘记清空TLB。
* 注意理解引用机制：释放的是逻辑地址（线性地址），它是一定没用了的，即映射关系一定要解除；但是，物理内存的内容可能还有引用的，所以未必需要释放物理空间。


#####100、和答案实现的区别
