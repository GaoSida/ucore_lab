# Lab 2 Report
计35 高思达 2013011413

gsd13@mails.tsinghua.edu.cn

## 练习〇 填写已有实验
使用meld工具可以很方便地进行代码的合并，只需要输入命令：`meld /lab1 /lab2`就能出现图形化的目录对比页面。点开文件后，两个文件中的不一样的地方可以很简单地通过点击来进行同步。但是，由于两个lab之间不同的文件比较多，所以还是需要查阅之前的报告来需找上次更改过的文件。lab1中更改过的是`kern/debug/kdebug.c`和`kern/trap/trap.c`。

由于lab1的challenge没有自己完成，而只是阅读了答案的代码，并直接拷贝到了lab1中添加注释，所以在lab2中并没有加入这部分代码。

为了方便起见，每份报告的一开始都会列出本次实验修改的文件：

* `kern/mm/default_pmm.c`


## 练习一 实现 first-fit 连续物理内存分配算法
#####0、本练习中涉及到的原理课中的知识点
涉及了物理内存的分配算法（First Fit）。在阅读代码中，还需要对分段和分页机制有所了解。

在原理课之外，代码实现中还涉及了对可用物理内存的初始化管理，以及对于页/空闲快标志位的设置细节，这些都是原理课中没有涉及的。

#####1、初步理解代码
* 我们在初始化内存管理的时候，使用的是`default_pmm_manager`，我们实现也是实现它的接口；
* `free_area_t`是真的存放在空闲内存块的头部的，所以其中只有前后指针和大小，而没有指向内存块的指针（或者类似的成员）；
* `default_init`初始化，不涉及探测可用空间的任务，只是准备好一个空的数据结构。

#####2、init\_memmap的理解和实现
* 探测物理内存通过系统调用，所谓`E820`是调用参数；BIOS中通过系统调用填写了这一部分，即存在了`e820map`；
* 调用`init_memmap`的函数是`page_init`，需要注意的是，这时ucore运行在保护模式下，有段机制，所以寻址时的逻辑地址都带有`0xC0000000`的偏移，比如该函数中的`end`。在`page_init`中，函数首先遍历`e820map`中的空闲地址块，统计页数，分配`Page`数组的空间。然后再对每一块调用`init_memmap`；
* 维护标志位时，只关注每一块的第一页即可，因为只有第一页是维护在空闲链表中的。

#####3、alloc\_pages的实现
* 需要修改的部分主要是页标志的设置，以及对于剩下的空闲空间插入链表的位置（插入后要保证地址递增）。

#####4、free\_pages的实现
* 原本的实现，应该不是针对first_fit的，该实现中没有利用链表的有序性（地址升序），也没有正确地插入新的空闲快；
* 重构这个函数，首先遍历链表找到插入位置，并插入刚刚释放的块；
* 然后，利用链表的有序性，我们只需要向前看一块，向后看一块，进行合并即可；合并时就不用遍历整个链表了。
* 这个函数一开始使用了一个循环更改区间内所有页的标志位，实际上只更改base的标志就够了；全部更改反而无法通过测试。

#####5、算法的改进空间
算法中，明显效率低下的地方是在回收空间时，把新的空闲快插入链表时，需要遍历链表。这个定位过程最坏情况下要遍历所有的空闲块（整个内存空间）。可以使用一些高级的数据结构，比如平衡树等，来加快这一查找定位过程。

#####6、和答案实现的区别
答案中，把每一个空闲页都加入了链表管理。然而事实上，只需要管理较大的内存块，链表中只需要放每块的第一页即可。如果每一页都在链表中，回收内存时的定位过程将会花费更多时间。在我的实现中，空闲链表中只管理每块开头的一页。和同学的讨论中发现，在建立了页机制后，反正也是一页一页地分配，所以即便像我这么实现，到最后还是一页一页地管理，效果是一样的。

同时，我只保留了必要的状态位修改和设置过程，并不像答案中做的那么冗余。标志位的设置方法，因为一开始没有看到代码中的注释，比较费解，但其实是很清晰的。Property位仅对于空闲块的头部页为1，否则为0；而Reserved仅仅对kernel保留的页是1，也就是所有可分配的页都是0。对应的注释在`kern/mm/memlayout.h`的108和109行。


## 练习二 实现寻找虚拟地址对应的页表项
#####0、本练习中涉及到的原理课中的知识点


#####1、


#####100、和答案实现的区别


## 练习三 释放某虚地址所在的页并取消对应二级页表项的映射
#####0、本练习中涉及到的原理课中的知识点


#####1、


#####100、和答案实现的区别
